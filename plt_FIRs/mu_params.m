function info = mu_params(PLACE, info, order, out_name)
%% written by K.Garner, 2020
% for each condition, average across the nth parameter across the sessions
% do this for 1 to N parameters
% save the output with a condition label

% idea of this function is to take the peaks image, and iterate through
% masks (anatomical), for each brain region the distribution of mean peak
% values is selected, and is then segmented according to x criteria. These
% criteria are then used to make n new mask files.

% inputs
% PLACE = where is your data? give the name of your data storage system to
% load the correct template file paths and to load library functions
% info = the information structure generated by mk_int_msks.m (see in this
% folder) 
% order = the order of the FIR model
% out_name = a sting ending in .nii, which is the template for the output
% files e.g. sub%s_TR%s_cond%d_order%d.nii

%% start here by defining path parameters et al
switch PLACE
    case 'inode'
        %spms = '/scratch/qbi/uqkgarn1/STRIWP1/derivatives/glmFIR/sub-%s/TR%s/FLGLM/SPM.mat';
        dat =  '/scratch/qbi/uqkgarn1/STRIWP1/derivatives/glmFIR/sub-%s/TR%s/FLGLM/PARAMS/';
        msks = '/scratch/qbi/uqkgarn1/STRIWP1/derivatives/glm/sub-%s/TR%s/MASKS/';
        addpath('/scratch/qbi/uqkgarn1/spm12/spm12')
end

sub = info.sub;
TR = info.TR;
nSess = max(info.sessions);
nConds = max(info.conds);
sidx = info.sessions;
cidx = info.conds;
flg.dtype = info.flg.dtype;

%% now make a s x p x c matrix, as an index for which images should be averaged together,
% reshape it and generate an appropriate condition idx for ease of use in the next step
idx = zeros(nSess, order, nConds);
for iSess = 1:nSess
    for iCond = 1:nConds
        idx(iSess, :, iCond) = find(sidx == iSess & cidx == iCond);
    end
end
sz = size(idx);
idx = reshape(idx, [sz(1), sz(2)*sz(3)]);
cidx = repelem(unique(cidx(cidx>0)), order);
oidx = repmat(1:order, [1, max(cidx)]);

%% now for every column in idx, get the volume information, average the images and then 
% average across the two images
%% select files of interest
fs = dir([sprintf(dat, sub, TR), 'beta*.nii.gz']); % get list of files
% now sanity check we have the right number of files
if (size(fs,1) ~= length(sidx))
    msg = sprintf('wrong number of beta images for sub %s, TR %s!', sub, TR);
    error(msg)
end

%% go through each column in idx, unzip and read in the relevant beta files,
% calculate the mean of the two images, and save
% first make the function for imcalc
f = '(';
for iSess = 1:size(idx,1)
    if iSess < size(idx,1)
        f = [f, sprintf('i%d+',iSess)];
    else
        f = [f, sprintf('i%d',iSess)];
    end
end
f = [f, sprintf(')/%d', iSess)];

for iMus = 1:size(idx, 2) % for each averaging I want to do
    % define images and unzip
    count = 0;
    for iSess = 1:size(idx)
        count = count+1;
        ims(count) = gunzip([fs(idx(iSess,iMus)).folder, '/' fs(idx(iSess,iMus)).name]);
    end
    % now read in the images
    for iIms = 1:length(ims)
        V(iIms) = spm_vol(ims{iIms});
    end
    % make mean image
    oname = [fs(idx(iSess,iMus)).folder, '/' sprintf(out_name, sub, TR, cidx(iMus), oidx(iMus))];
    muP = spm_imcalc(V, oname, f, flg);
    % zip the image
    sf=gzip(muP.fname); % sf = for saving to the info folder
    info.muparams(iMus).name = sf{1};    
    delete(muP.fname);
    % delete the other .nii images
    for iDel = 1:length(ims)
        delete(ims{iDel});
    end    
end
end